function [collectingPosNeural,nil1,nil2] = collectingPosNetwork(collectingInput,x,y)
%MYNEURALNETWORKFUNCTION neural network simulation function.
% 
% Generated by Neural Network Toolbox function genFunction, 14-Sep-2018 13:47:25.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 4xQ matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 2xQ matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0.00119239540528857;0.0137152197738708;0.00133120937584319;0.0118391291861168];
x1_step1.gain = [0.0133716704733847;0.0134390209276308;0.0133508600020281;0.0133637161412659];
x1_step1.ymin = -1;

% Layer 1
b1 = [-0.45708221773873330962;0.0086596439256617276786;-0.63141452845654266746;-0.61681404244166115891;0.0090162469622450201051;0.49829405569663959286;0.18131312024082454903;-0.81197489203686390447;-0.17034921181564788295;0.40838464185874162604;0.089194235640822641664;0.09000110513223713582;-0.72051572743020986245;1.9741386532248559327;-0.0083712521411030121204;0.63432445109987378729];
IW1_1 = [0.056169790781948877867 0.021414217822521147694 0.037807524302591488663 0.28374739584389691016;-15.840149224859153776 0.91312311557444392207 15.839800448807418221 -0.013850977430626763842;15.328821072461252584 -15.800562578910314571 -15.238540177333167236 15.97922517060540315;15.208862700650685795 -15.686763360495463715 -15.124718042641733362 15.859570282047485534;-0.10670744768057449647 -0.041628476526574392791 0.14226110750822798523 0.042055684310387780878;0.13719354173965239707 0.10435182586431709928 0.10465983650782746672 0.69973782660350714036;-15.454276482381594349 -15.121159448818939808 15.329065934476471256 14.590714563391248504;0.76311875921569527481 -1.8884411471195898802 -1.1350596863619930588 -1.7252853265479439759;15.456210164207714541 15.070067676420164204 -15.357209775093727089 -14.630169286551796048;-0.98837345336408910512 0.36246595738359344008 -2.8038706770209991248 0.62401124048942091527;-1.1619473605738559474 -16.504986663988255202 0.15488118504021242128 16.655205330858233737;-1.1947331549273305651 -16.638217125533717677 0.15397461477884133441 16.789780320749766673;0.052168823323169639938 0.02018752328400310464 -0.30646725482201347956 0.12085581995757822826;0.1102738487041204779 0.023642414280856234587 0.071546174720001395886 0.56194212938527698942;15.929192975381255337 -0.94020280485970286755 -15.92912246734447379 0.012247729945833941284;0.041182298430083710827 0.016640060953618911188 -0.24070383992122323935 0.095176845756693106981];

% Layer 2
b2 = [0.20371975138091927282;-0.97869547266583345468];
LW2_1 = [1.4861616713845950954 0.51210137898852303717 0.49686612089329118547 -0.50510924426699232992 -0.85262367300790298241 0.1000412123226966099 -0.070069844654731830436 0.00012461045736549458598 -0.078280641457462968313 -0.00045535326235492730885 -0.016502862807867894196 0.016869435643607839231 -2.2842640074160036612 1.0703775174681489091 0.50209306152515553734 -3.646747834564322055;2.4705203852932386965 -0.0093586811685748977352 -0.54122619495956025837 0.54972137708780122178 1.9981029981308668919 0.1689643588288045617 -0.069742387350507806243 0.0010655480210684403243 -0.077483122294014647458 0.0002392726744430806571 0.47479774312525924174 -0.46463786030729670173 0.84133939429089354967 1.7707066270062543634 -0.0091460546468003240533 1.3443889272377007593];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0130374946678367;0.0130372946015166];
y1_step1.xoffset = [-1.81172402410438;-1.7497098038299];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(collectingInput);
if ~isCellX
    collectingInput = {collectingInput};
end

% Dimensions
TS = size(collectingInput,2); % timesteps
if ~isempty(collectingInput)
    Q = size(collectingInput{1},2); % samples/series
else
    Q = 0;
end

% Allocate Outputs
collectingPosNeural = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    Xp1 = mapminmax_apply(collectingInput{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    collectingPosNeural{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
nil1 = cell(1,0);
nil2 = cell(2,0);

% Format Output Arguments
if ~isCellX
    collectingPosNeural = cell2mat(collectingPosNeural);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
