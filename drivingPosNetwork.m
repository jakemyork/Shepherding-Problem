function [drivingPosNeural,nil1,nil2] = drivingPosNetwork(drivingInput,x,y)
%MYNEURALNETWORKFUNCTION neural network simulation function.
% 
% Generated by Neural Network Toolbox function genFunction, 14-Sep-2018 13:52:21.
%
% [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
%
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 4xQ matrix, input #1 at timestep ts.
%
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 2xQ matrix, output #1 at timestep ts.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0.00119239540528857;0.0137152197738708;0.00188383021799648;0.0180085027829476];
x1_step1.gain = [0.0133716704733847;0.0134390209276308;0.00985145207107693;0.00990081806397617];
x1_step1.ymin = -1;

% Layer 1
b1 = [3.1701272138197618133;-8.7399531243863588514;8.9265785002757969124;-2.2061252626718230729;10.290503068869002234;-3.2285101568557434959;-1.3760432695755249188;1.3319901726228846606;-1.3963732282456116085;0.42342848851257991472;-0.11844967204750712908;0.43367178503921199884;-0.4255249907923231989;0.45163935675310473705;-0.50726170026647121603;-0.89049128519654252578];
IW1_1 = [-0.68248232516124041069 0.080034522609080699374 -1.2176078419146882936 2.2911933732221227977;-1.8413407810803172904 -0.43692392377477290433 -3.834405345042507296 -1.6855873226964408484;2.1583073083989989804 0.45520553216677434039 4.2198302407941863379 1.6895388542551130762;1.2377115086544883127 -1.8152956589368645091 1.9951160210101905879 1.2391366057007016099;0.88834370855249866761 0.78341166937076722743 2.0508715657496945362 4.8746292101873773817;0.40789621298516126613 -0.8746404357821510045 -0.32979162319853910779 -2.7700734138181593025;0.82607442782165119155 -1.1905319896820605319 0.5524213919899548797 -2.536034208162149195;-0.76575404917580336406 1.0934803481456776275 -0.57346130270343376178 2.462496997386828923;0.0030346863357228071739 -0.0072314638298227240307 -0.26064786092642572291 -0.13199351137354714547;1.2117951580423003133 -1.0209063274542382604 1.8888451525352834004 -1.5303833403856927919;-0.0022582740294223194004 0.0022465466624565872886 0.088381672959718521332 -0.095467140089038268758;1.2026849808929700458 -1.0449560980684067246 1.8262239276618101869 -1.7021438925836320788;-1.2665618933029061388 1.046553877747818051 -1.9509846683225180453 1.4282506888924075827;1.2521141927168906172 -1.1120812712597225591 1.8005702261526936869 -1.8481451181558177232;-0.0039103894550303920641 0.0031073134352187672773 0.23991649357986061242 0.1012546188295585653;-0.15068866597981381283 0.13665802245543257065 -0.65236105993894999422 0.61299732546604612793];

% Layer 2
b2 = [-1.9783505390380535793;-2.4611741794563157804];
LW2_1 = [-0.014379031942816396586 -2.5258788120758630669 -0.81034193701272805299 -0.00025946042227520247541 -1.8680169091948386484 0.012930781470986838638 -0.22484729883036197462 -0.25422338523436405211 -4.0458770623367330543 -2.6140626580737129636 2.6562962543672457016 2.6403718010822152529 -1.0419318864419349069 -1.059628724899254637 2.494325765920646365 -0.14226697920609521208;-0.009587287169573856585 3.5298484876988376335 1.2113429985146140222 -0.007710775004045003489 2.4523313484716520172 -0.016673753493905946882 0.074036036178293490595 0.083854399849668304068 -2.9927053125204543527 -2.5111436128910944454 -7.2750534552707017966 2.1962925158732575781 -1.1101454344166787891 -0.80488543008585156091 2.4766897023869569594 0.027541393033363236603];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.00948011799249758;0.00950399704884456];
y1_step1.xoffset = [0.00469624784316719;0.0215979278514166];

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(drivingInput);
if ~isCellX
    drivingInput = {drivingInput};
end

% Dimensions
TS = size(drivingInput,2); % timesteps
if ~isempty(drivingInput)
    Q = size(drivingInput{1},2); % samples/series
else
    Q = 0;
end

% Allocate Outputs
drivingPosNeural = cell(1,TS);

% Time loop
for ts=1:TS
    
    % Input 1
    Xp1 = mapminmax_apply(drivingInput{1,ts},x1_step1);
    
    % Layer 1
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*Xp1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    drivingPosNeural{1,ts} = mapminmax_reverse(a2,y1_step1);
end

% Final Delay States
nil1 = cell(1,0);
nil2 = cell(2,0);

% Format Output Arguments
if ~isCellX
    drivingPosNeural = cell2mat(drivingPosNeural);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
